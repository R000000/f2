## Functions to extract shared haplotypes from genotype data using f2 variants.

########################################################################################################
## Find all the shared haplotypes given genotypes and f2s
## f1.file: list of f1 variants generated by calculate_fn_sites.py
## f2.file: list of f2 variants generated by calculate_fn_sites.py
## pos.file: variant positions
## by.sample.gt.root: path to the directory which has the per-sample genotype files
## population: restrict to this population
## map: genetic map
## chr: chromosome
########################################################################################################

find.haplotypes.from.f2 <- function( f1.file, f2.file, pos.file, by.sample.gt.root, pop.map, population=NA, map.file, chr=0, verbose=FALSE  ){
  f2 <- load.fn(f2.file)
  f1 <- load.fn(f1.file)
  pos <- scan(pos.file, quiet=TRUE)
  haplen <- length(pos)

  mapfn <- get.mapfn(map.file)
    
  f2 <- f2[pop.map[f2$ID1]==population|pop.map[f2$ID2]==population,]
  f2 <- f2[order(f2$ID1,f2$ID2),]
  f2$chr <- chr
  f2$ID.from <- ifelse(pop.map[f2$ID1]==population, f2$ID1, f2$ID2)
  f2$ID.to <- ifelse(pop.map[f2$ID1]==population, f2$ID2, f2$ID1)
  f2$hap.len <- 0
  f2$hap.left <- 0
  f2$hap.right <- 0
  f2$f1 <- 0
  f2$f2 <- 0
  f2$map.len <- 0

  number.f2 <- NROW(f2)
  
  last.ibd.pos=c(-1,-1)
  last.ID.to=-1
  last.ID.from=-1

  for(i in 1:number.f2){
    if(verbose){cat(paste("\rChr", chr, " (", i, "/", number.f2,") ", sep=""))}
    this.pos <- f2$pos[i]
    this.ID.to <- f2$ID.to[i]
    this.ID.from <- f2$ID.from[i]

    #skip if f2 in single indiviudal.
    if(this.ID.from==this.ID.to){next}
    #skip if still in the previous chunk - relies on the data being odered as above
    if(this.pos<last.ibd.pos[2] & this.ID.to==last.ID.to & this.ID.from==last.ID.from){next}       

    ## Lazy load data - this means that we only load each from genotype once, since they are sorted.
    if(this.ID.from!=last.ID.from){
        from.hap.file <- paste( by.sample.gt.root, "/", names(pop.map)[this.ID.from], ".gt.gz", sep ="")
        from.hap <- scan(from.hap.file, nmax=haplen, quiet=TRUE)
    }
    if(this.ID.to!=last.ID.to){
      to.hap.file <- paste( by.sample.gt.root, "/", names(pop.map)[this.ID.to], ".gt.gz", sep ="")
      to.hap <- scan(to.hap.file, nmax=haplen, quiet=TRUE)
    }
    
    ibd <- find.inconsistent.hom(from.hap, to.hap, pos, this.pos, haplen)
    ibd.pos <- pos[ibd]
    hap.len <- ibd.pos[2]-ibd.pos[1]

    ## Note here for doubletons, we really mean >/< rather than >=/<=. However since the breakpoints are inconsistent homozygotes
    ## they can't be consistent doubletons so it doesn't matter and >/< handles the case where the f2 is at the end of the chrom. 
    singletons <- NROW(f1[(f1$ID1==this.ID.from|f1$ID1==this.ID.to) & f1$pos>ibd.pos[1] & f1$pos<ibd.pos[2],])
    doubletons <- NROW(f2[((f2$ID1==this.ID.from&f2$ID2==this.ID.to)|(f2$ID2==this.ID.from&f2$ID1==this.ID.to)) & f2$pos>=ibd.pos[1] & f2$pos<=ibd.pos[2],])
    
    f2$hap.len[i] <- hap.len
    f2$hap.left[i] <- ibd.pos[1]
    f2$hap.right[i] <- ibd.pos[2]
    f2$f1[i] <- singletons
    f2$f2[i] <- doubletons
    f2$map.len[i] <- (mapfn(ibd.pos[2])-mapfn(ibd.pos[1]))/100
    
    last.ID.from <- this.ID.from
    last.ID.to <- this.ID.to
    last.ibd.pos <- ibd.pos
  }

  ## Exclude samples which either hit the ends of the chromosome, or which have 0 length 
  exclude <- (f2$hap.len==0) | (f2$hap.right==max(pos)) | (f2$hap.left==min(pos))
  
  return(f2[!exclude,])
}

########################################################################################################
## Count the number of singletons between two positions. Really only used for testing
## IDS: two columns of sample IDS
## starts, ends: columns of start and end positions.
## f1.file: list of f1 variants generated by calculate_fn_sites.py
########################################################################################################

count.singletons.from.positions <- function(IDS, starts, ends, f1.file){
  f1 <- load.fn(f1.file)

  S <- rep(0, length=length(starts))
  for(i in 1:length(starts)){
    S[i] <- sum((f1$ID1==IDS[i,1]|f1$ID1==IDS[i,2]) & (f1$pos>starts[i] & f1$pos<ends[i]))
  }
  return(S)
}

########################################################################################################
## Given two haplotypes and an index, find the indices of the first
## inconsistent homozygotes, to the left and the right of pos
## gt1, gt2: genotype vectors
## gt.pos: variant positions
## pos: position to check
########################################################################################################

find.inconsistent.hom <- function(gt1, gt2, gt.pos, pos, len=length(gt1)){
  idx.l <- max(1,findInterval(pos, gt.pos))
  idx.r <- idx.l+1
  if(gt.pos[idx.l]==pos){idx.r <- idx.l}

  idx.l <- max(1,idx.l-1)
  while(idx.l>1 & !((gt1[idx.l]==0 & gt2[idx.l]==2)|(gt1[idx.l]==2 & gt2[idx.l]==0))){
    idx.l <- idx.l-1
  }
  idx.r <- min(len, idx.r+1) 
  while(idx.r<len & !((gt1[idx.r]==0 & gt2[idx.r]==2)|(gt1[idx.r]==2 & gt2[idx.r]==0))){
    idx.r <- idx.r+1
  }
  return(c(idx.l, idx.r))
}

########################################################################################################
## Load the fn file generated with calculate_fn_sites.py
## first column in position and the next n columns are the indices
## of the samples which share those variants. These are haplotype
## samples, so we divide the indexes by two. Also convert from
## 0 to 1-based indexing, assuming that the python output is 0-based. 
########################################################################################################

load.fn <- function(fn.file){
  fn <- read.table(fn.file, as.is=TRUE, header=FALSE)
  idx.range <- 2:length(fn)

  fn[,idx.range] <- fn[,idx.range]+1                  #0 based -> 1 based
  colnames(fn) <- c("pos", paste( "ID", idx.range-1, sep=""))
  ## Convert IDs to (genotype) sample indices
  fn[,idx.range] <- ceiling(fn[,idx.range]/2)
  return(fn)
}

########################################################################################################
## load the recombination map. If it's a number, make that the constant rate, in cM/Mb
## if it's a file, load the map.
########################################################################################################

get.mapfn <- function(map.file){
  mapfn <- NULL
  if(!is.numeric(map.file)){
    map <- read.table(map.file, as.is=TRUE, header=TRUE)
    mapfn <- approxfun(map$Position.bp. , map$Map.cM. , rule=2, method="linear")
  } else{
    r <- as.numeric(map)
    mapfn <- approxfun(c(0, 1e9), c(0,r*1e3), rule=1, method="linear") #only going up to 1cm, but rule=1 ensure NA outside this. 
  }
  return(mapfn)
}

########################################################################################################
## From a set of sample genotypes, sample pairs at random, then sample points at
## random, then get the left and right distance to the nearest incompatible hom
## and finally, fit a gamma distribution to the distribution of total distances.
## path.to.samples: path to genotype files
## samples: file list of sample names
## map.file: genetic map
## pairs, each: sample each points from pairs sets of individuals
## verbose: report progress
## direction: either count randomly left or right and then double the distribution, or count both
## ways and estimate the total. These give different answers because the results are correlated. 
########################################################################################################

fit.gamma.to.error <- function(path.to.samples, map.file, samples1, samples2=samples1 , pairs=1000, each=1000, verbose=FALSE, direction=c("one.way", "two.way")){
  LOWER.BOUND <- 1e-6                   #just to help with optimization
  pos <- scan(paste(path.to.samples, "/pos.gz", sep=""), quiet=TRUE)
  map <- get.mapfn(map.file)
  n1 <- length(samples1)
  n2 <- length(samples2)
  l <- length(pos) 
  p1 <- sort(sample(n1, size=pairs, replace=TRUE))
  p2 <- sample(n2, size=pairs, replace=TRUE)

  results.l <- rep(0, pairs*each)
  results.r <- rep(0, pairs*each)

  if(verbose){cat("Estimating length overestimate parameters\n")}
  for(i in 1:pairs){
    while(p2[i]==p1[i]){p2[i] <- sample(n2, size=1)} #just in case we accidentally picked the same person. 
    if(verbose){cat(paste("\r", i, "/", pairs, sep="" ))}
    gt1 <- scan(paste( path.to.samples, "/", samples1[p1[i]], ".gt.gz", sep =""), quiet=TRUE, nmax=l)
    gt2 <- scan(paste( path.to.samples, "/", samples2[p2[i]], ".gt.gz", sep =""), quiet=TRUE, nmax=l)
    
    for(j in 1:each){
      x <- sample(min(pos):max(pos), size=1)
      pts <- find.inconsistent.hom(gt1, gt2, pos, x, l)
      ps <- pos[pts]
      results.l[pairs*(i-1)+j] <- map(x)-map(ps[1])
      results.r[pairs*(i-1)+j] <- map(ps[2])-map(x)
    }
  }
  if(verbose){cat("\n")}

  if(direction[1]=="one.way"){
    results <- ifelse(runif(pairs*each)<0.5, results.l, results.r) #r and l are correlated, so we want one sided only. 
    fit <- fitdistr(results[results>0], "gamma", lower=rep(LOWER.BOUND, 2))
    error.params <- fit$estimate
    error.params[1] <- error.params[1]*2  #double shape parameter since the overestimate is on both sides
  }else if(direction[1]=="two.way"){
    results <- results.l+results.r
    fit <- fitdistr(results[results>0], "gamma", lower=rep(LOWER.BOUND, 2))
    error.params <- fit$estimate
  }else{ stop("Don't recognise direction")}
  
  error.params[2] <- error.params[2]*100  #convert to Morgans
  return(error.params)
}

